(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{600:function(t,e,a){"use strict";a.r(e);var s=a(4),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"storage-maps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#storage-maps"}},[t._v("#")]),t._v(" Storage Maps")]),t._v(" "),a("p",[a("code",[t._v("pallets/simple-map")]),t._v(" "),a("a",{attrs:{href:"https://playground-staging.substrate.dev/?deploy=recipes&files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fsimple-map%2Fsrc%2Flib.rs",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate",alt:"Try on playground"}}),t._v(" "),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-map/src/lib.rs",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github",alt:"View on GitHub"}}),t._v(" "),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("In the appetizer on "),a("RouterLink",{attrs:{to:"/zh/2-appetizers/2-storage-values.html"}},[t._v("storage values")]),t._v(" we learned to store a\nsingle value in blockchain storage to be persisted between blocks. In this recipe, we will see how\nto store a mapping from keys to values, similar to Rust's own\n"),a("a",{attrs:{href:"https://doc.rust-lang.org/std/collections/struct.HashMap.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("HashMap")]),a("OutboundLink")],1),t._v(".")],1),t._v(" "),a("h2",{attrs:{id:"declaring-a-storagemap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#declaring-a-storagemap"}},[t._v("#")]),t._v(" Declaring a "),a("code",[t._v("StorageMap")])]),t._v(" "),a("p",[t._v("We declare a single storage map with the following syntax.")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("decl_storage!")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("trait")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Store")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Module")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Trait")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpleMap")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpleMap")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("simple_map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" map "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("hasher")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("blake2_128_concat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountId")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("u32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Much of this should look familiar to you from storage values. Reading the line from left to right we\nhave:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("SimpleMap")]),t._v(" - the name of the storage map")]),t._v(" "),a("li",[a("code",[t._v("get(fn simple_map)")]),t._v(" - the name of a getter function that will return values from the map.")]),t._v(" "),a("li",[a("code",[t._v(": map hasher(blake2_128_concat)")]),t._v(" - beginning of the type declaration. This is a map and it will\nuse the\n"),a("a",{attrs:{href:"https://substrate.dev/rustdocs/v2.0.0-rc4/frame_support/trait.Hashable.html#tymethod.blake2_128_concat",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("blake2_128_concat")]),a("OutboundLink")],1),t._v("\nhasher. More on this below.")]),t._v(" "),a("li",[a("code",[t._v("T::AccountId => u32")]),t._v(" - The specific key and value tyes of the map. This is a map from\n"),a("code",[t._v("AccountId")]),t._v("s to "),a("code",[t._v("u32")]),t._v("s.")])]),t._v(" "),a("h2",{attrs:{id:"choosing-a-hasher"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#choosing-a-hasher"}},[t._v("#")]),t._v(" Choosing a Hasher")]),t._v(" "),a("p",[t._v("Although the syntax above is complex, most of it should be straightforward if you've understood the\nrecipe on storage values. The last unfamiliar piece of writing a storage map is choosing which\nhasher to use. In general you should choose one of the three following hashers. The choice of hasher\nwill affect the performance and security of your chain. If you don't want to think much about this,\njust choose "),a("code",[t._v("blake2_128_concat")]),t._v(" and skip to the next section.")]),t._v(" "),a("h3",{attrs:{id:"blake2-128-concat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blake2-128-concat"}},[t._v("#")]),t._v(" "),a("code",[t._v("blake2_128_concat")])]),t._v(" "),a("p",[t._v("This is a cryptographically secure hash function, and is always safe to use. It is reasonably\nefficient, and will keep your storage tree balanced. You "),a("em",[t._v("must")]),t._v(" choose this hasher if users of your\nchain have the ability to affect the storage keys. In this pallet, the keys are "),a("code",[t._v("AccountId")]),t._v("s. At\nfirst it may "),a("em",[t._v("seem")]),t._v(" that the user doesn't affect the "),a("code",[t._v("AccountId")]),t._v(", but in reality a malicious user\ncan generate thousands of accounts and use the one that will affect the chain's storage tree in the\nway the attacker likes. For this reason, we have chosen to use the "),a("code",[t._v("blake2_128_concat")]),t._v(" hasher.")]),t._v(" "),a("h3",{attrs:{id:"twox-64-concat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#twox-64-concat"}},[t._v("#")]),t._v(" "),a("code",[t._v("twox_64_concat")])]),t._v(" "),a("p",[t._v("This hasher is "),a("em",[t._v("not")]),t._v(" cryptographically secure, but is more efficient than blake2. Thus it represents\ntrading security for performance. You should "),a("em",[t._v("not")]),t._v(" use this hasher if chain users can affect the\nstorage keys. However, it is perfectly safe to use this hasher to gain performance in scenarios\nwhere the users do not control the keys. For example, if the keys in your map are sequentially\nincreasing indices and users cannot cause the indices to rapidly increase, then this is a perfectly\nreasonable choice.")]),t._v(" "),a("h3",{attrs:{id:"identity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#identity"}},[t._v("#")]),t._v(" "),a("code",[t._v("identity")])]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("identity")]),t._v(' "hasher" is really not a hasher at all, but merely an\n'),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Identity_function",target:"_blank",rel:"noopener noreferrer"}},[t._v("identity function"),a("OutboundLink")],1),t._v(" that returns the same value it\nreceives. This hasher is only an option when the key type in your storage map is "),a("em",[t._v("already")]),t._v(" a hash,\nand is not controllable by the user. If you're in doubt whether the user can influence the key just\nuse blake2.")]),t._v(" "),a("h2",{attrs:{id:"the-storage-map-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-storage-map-api"}},[t._v("#")]),t._v(" The Storage Map API")]),t._v(" "),a("p",[t._v("This pallet demonstrated some of the most common methods available in a storage map including\n"),a("code",[t._v("insert")]),t._v(", "),a("code",[t._v("get")]),t._v(", "),a("code",[t._v("take")]),t._v(", and "),a("code",[t._v("contains_key")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Insert")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpleMap")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("insert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" entry"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Get")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" entry "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpleMap")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("account"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Take")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" entry "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpleMap")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("take")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Contains Key")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SimpleMap")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("contains_key")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("The rest of the API is documented in the rustdocs on the\n"),a("a",{attrs:{href:"https://substrate.dev/rustdocs/v2.0.0-rc4/frame_support/storage/trait.StorageMap.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("StorageMap")]),t._v(" trait"),a("OutboundLink")],1),t._v(". You do\nnot need to explicitly "),a("code",[t._v("use")]),t._v(" this trait because the "),a("code",[t._v("decl_storage!")]),t._v(" macro will do it for you if you\nuse a storage map.")])])}),[],!1,null,null,null);e.default=n.exports}}]);